path /provider {

  /oauth1/{consumerKey} {
    read() { isWorker() }

    /credentials is OauthKey {
      validate() { this.key == $consumerKey }
      create() { true }
    }

    /nonces/{nonce}/expireAt is Number {
      create() { isWorker() }
      delete() { isWorker() && prior(this) < now }
    }
  }

  /launches/{consumerKey}/{resourceLinkId} {
    read() { isWorker() }
    write() { isWorker() }

    /info is Activity {
      validate() { this.domain == $consumerKey && this.resourceLinkId == $resourceLinkId }
    }

    /users/{userId} {
      read() { isUser(userId) }

      /solution {
        write() { isUser(userId) }

        /clicked is Boolean;
      }

      /grade is Number;

      /sourceDid is String;

      /outcomeTask is String;

    }

  }

  /outcomes/queue {
    index() { ['started', 'startedAt'] }
    read() { isWorker() }

    /{taskId} is Task<OutcomeRequest> {
      write() { isWorker() }
    }
  }

}

type OauthKey {
  key: String;
  secret: String;
  createdAt: InitialTimestamp | Null;
}

type Activity {
  lti: LTI;
  domain: String;
  resourceLinkId: String;
  contextId: String | Null;
  toolConsumerGuid: String | Null;
  outcomeService: OutcomeService | Null;
}

type LTI {
  messageType: String;
  version: String;
}

type OutcomeService {
  url: String | Null;
  dataType: Boolean[] | Null;
}

type OutcomeRequest {
  // We do not denormalise the user source_did or grade because we need to
  // load the user data anyway (to check the task still need to run).
  consumerKey: String;
  linkId: String;
  userId: String;
  service: OutcomeService;
  consumer: OauthKey;
}

type CurrentTimestamp extends Number {
  validate() { this == now }
}

type InitialTimestamp extends Number {
  validate() { initial(this, now) }
}

type Task<T> extends T {
  started: Boolean;
  createdAt: InitialTimestamp;
  startedAt: Number | Null;

  validate() {
    this.startedAt == prior(this.startedAt)
    || (
      (this.startedAt == now || this.startedAt == null)
      && (isNew(this.startedAt) || timedOut(this.startedAt, 20000))
    )
  }
}

isNew(value) { prior(value) == null }

initial(value, init) { value == (isNew(value) ? init : prior(value)) }

timedOut(value, delta) { prior(value) < (now - delta) }

isWorker() { auth != null && auth.isWorker == true }

isUser(userId) { auth != null && userId == auth.uid }
